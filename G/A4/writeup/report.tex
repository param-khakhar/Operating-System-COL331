\documentclass[12pt]{article}
\usepackage[utf8]{inputenc}
\usepackage[english]{babel}
\usepackage{amsmath}
\usepackage{graphicx}
\usepackage{booktabs,floatrow}
\graphicspath{ {../output/}}

\usepackage{hyperref}
\hypersetup{
    colorlinks=true,
    linkcolor=blue,
    filecolor=magenta,      
    urlcolor=black,
}

\title{COL331 Operating System : Assignment - 4}
\author{Param Khakhar - 2018CS10362}
\date{24 March 2021}

\begin{document}

\maketitle

\section *{Introduction}

The following is a writeup for the Assignment-4, Operating System (COL331). There are two sections corresponding to part A and part B, and each section contains the answers of the respective tasks in the path.

\section*{Part A}

\subsection*{Task - 1: Output of t1}

After printing "Executing t1", the program terminates with the string printed "Execution of 't1' complete".

\subsection*{Task - 2: MACROS Description}

There are generic MACROS defined depending on the number of arguments which are called in the orginal syscall depending on the number of arguments. SYSCALL0 only takes the syscall number as the argument, SYSCALL1 takes the syscall number along with other argument, SYSCALL2 takes syscall number and two other arguments, and SYSCALL3 takes syscall number and three other arguements. All the arguments are pushed onto the stack with the syscall number at the top, along with the other arguments from top to bottom, in the same order in which the syscall is called.

\subsection*{Task - 3: Waiting Function}
The function
\begin{verbatim}
    int process_wait (tid_t child_tid);
\end{verbatim}

is where the kernel waits for a process to terminate. On using an infinite loop in the function the following message is printed: \\

"System calls not implemented"\\

\subsection*{Task - 4:}

The testcases for the seek, halt, filesize, and remove are added in the file test\_syscalls.c in the lib directory.

\section*{Part B}

\subsection*{Task - 1: Semaphore Function Interface}

Consider two threads A and B, both using a shared sempahore in order 
to achieve mutual exclusion. Without loss of generality, assume that 
the initial value of the semaphore is 1. If thread A, first calls, 
sema\_down(), then the value of the semaphore would then be 
decremented by 1, ultimately to 0. The other thread B, wouldn't 
complete the execution of the function sema\_down(), and would go 
to sleep. Thread B would sleep until thread A calls sema\_up(), which
would increment the value of the semaphore back to 1, and also remove
thread B from the waiting queue. \\

\noindent
Therefore, execution of sema\_down() followed by sema\_up() by the
same thread, would imply entry to the mutual exclusion region for other
competing threads.


\end{document}